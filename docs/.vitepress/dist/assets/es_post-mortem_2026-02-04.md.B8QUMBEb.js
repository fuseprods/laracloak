import{_ as a,o,c as s,ae as r}from"./chunks/framework.BFWHsNam.js";const h=JSON.parse('{"title":"Post-Mortem: Bloqueo de Dashboards en Producción (2026-02-04)","description":"","frontmatter":{},"headers":[],"relativePath":"es/post-mortem_2026-02-04.md","filePath":"es/post-mortem_2026-02-04.md"}'),i={name:"es/post-mortem_2026-02-04.md"};function t(n,e,l,d,c,u){return o(),s("div",null,[...e[0]||(e[0]=[r('<h1 id="post-mortem-bloqueo-de-dashboards-en-produccion-2026-02-04" tabindex="-1">Post-Mortem: Bloqueo de Dashboards en Producción (2026-02-04) <a class="header-anchor" href="#post-mortem-bloqueo-de-dashboards-en-produccion-2026-02-04" aria-label="Permalink to &quot;Post-Mortem: Bloqueo de Dashboards en Producción (2026-02-04)&quot;">​</a></h1><h2 id="resumen" tabindex="-1">Resumen <a class="header-anchor" href="#resumen" aria-label="Permalink to &quot;Resumen&quot;">​</a></h2><p>El 4 de febrero de 2026, se reportó que los dashboards en el entorno de producción estaban &quot;congelados&quot;, mostrando indicadores de carga persistentes en lugar de renderizar los datos de los widgets. Los datos llegaban al navegador (visibles en la pestaña Network de DevTools), pero la interfaz no se actualizaba.</p><h2 id="sintomas" tabindex="-1">Síntomas <a class="header-anchor" href="#sintomas" aria-label="Permalink to &quot;Síntomas&quot;">​</a></h2><ul><li>Los widgets se quedaban bloqueados en el estado &quot;Esperando datos...&quot;.</li><li>Las DevTools del navegador mostraban respuestas 200 OK con cargas JSON válidas.</li><li>El problema no era reproducible en el entorno de desarrollo local.</li></ul><h2 id="causas-raiz" tabindex="-1">Causas Raíz <a class="header-anchor" href="#causas-raiz" aria-label="Permalink to &quot;Causas Raíz&quot;">​</a></h2><h3 id="_1-validacion-estricta-de-content-type" tabindex="-1">1. Validación Estricta de Content-Type <a class="header-anchor" href="#_1-validacion-estricta-de-content-type" aria-label="Permalink to &quot;1. Validación Estricta de Content-Type&quot;">​</a></h3><p>En <code>front.js</code>, el código verificaba una coincidencia exacta de <code>application/json</code>.</p><ul><li><strong>Entorno local</strong>: Las cabeceras eran <code>application/json</code> limpio.</li><li><strong>Entorno de producción</strong>: El servidor/proxy añadía información de charset (ej: <code>application/json; charset=UTF-8</code>), lo que causaba que la verificación fallara y la carga fuera ignorada.</li></ul><h3 id="_2-variaciones-en-la-estructura-de-datos-upstream" tabindex="-1">2. Variaciones en la Estructura de Datos Upstream <a class="header-anchor" href="#_2-variaciones-en-la-estructura-de-datos-upstream" aria-label="Permalink to &quot;2. Variaciones en la Estructura de Datos Upstream&quot;">​</a></h3><p>El servicio upstream (n8n) a menudo devuelve datos envueltos en un array <code>[ { &quot;clave&quot;: &quot;valor&quot; } ]</code>.</p><ul><li><strong>Fallo</strong>: La implementación inicial de <code>getNestedValue</code> esperaba el objeto en la raíz. Al recibir un array, fallaba al encontrar las claves, dejando a los widgets sin datos.</li></ul><h3 id="_3-cache-agresiva-del-navegador" tabindex="-1">3. Caché agresiva del Navegador <a class="header-anchor" href="#_3-cache-agresiva-del-navegador" aria-label="Permalink to &quot;3. Caché agresiva del Navegador&quot;">​</a></h3><p>Tras desplegar las correcciones iniciales, el entorno de producción seguía fallando porque los navegadores servían una versión cacheada de <code>front.js</code> anterior a los arreglos.</p><h3 id="_4-falta-de-aislamiento-de-errores" tabindex="-1">4. Falta de Aislamiento de Errores <a class="header-anchor" href="#_4-falta-de-aislamiento-de-errores" aria-label="Permalink to &quot;4. Falta de Aislamiento de Errores&quot;">​</a></h3><p>Un fallo en la lógica de renderizado de un solo widget (o un desajuste de datos) podía potencialmente detener todo el bucle de renderizado, sin proporcionar feedback al usuario o desarrollador.</p><h2 id="resolucion" tabindex="-1">Resolución <a class="header-anchor" href="#resolucion" aria-label="Permalink to &quot;Resolución&quot;">​</a></h2><h3 id="resiliencia-del-frontend-front-js" tabindex="-1">Resiliencia del Frontend (<code>front.js</code>) <a class="header-anchor" href="#resiliencia-del-frontend-front-js" aria-label="Permalink to &quot;Resiliencia del Frontend (`front.js`)&quot;">​</a></h3><ul><li><strong>Cabeceras Robustas</strong>: Se cambió <code>contentType.includes(&#39;application/json&#39;)</code> para que sea insensible a mayúsculas y permita parámetros extra.</li><li><strong>Pathing Inteligente</strong>: Se añadió lógica para &quot;desenvolver&quot; automáticamente arrays de un solo elemento (estilo n8n) al resolver claves de datos.</li><li><strong>Aislamiento de Errores</strong>: Se envolvió cada llamada de renderizado de widget en un bloque <code>try/catch</code>. Si un widget falla, los demás continúan cargando.</li><li><strong>Logs de Depuración</strong>: Se añadieron grupos de consola y logs de inicio para proporcionar visibilidad inmediata sobre el estado del motor y los datos recibidos.</li></ul><h3 id="estabilizacion-del-backend" tabindex="-1">Estabilización del Backend <a class="header-anchor" href="#estabilizacion-del-backend" aria-label="Permalink to &quot;Estabilización del Backend&quot;">​</a></h3><ul><li><strong>Cabeceras Explícitas</strong>: Se forzó la cabecera <code>Content-Type: application/json</code> en <code>FrontController</code> al devolver cargas sanitizadas.</li></ul><h3 id="busting-de-cache" tabindex="-1">Busting de Caché <a class="header-anchor" href="#busting-de-cache" aria-label="Permalink to &quot;Busting de Caché&quot;">​</a></h3><ul><li><strong>Estrategia de Despliegue</strong>: Se añadió una versión basada en timestamp a la etiqueta script en <code>page.blade.php</code> para asegurar que siempre se cargue el código más reciente:<div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;{{ asset(&#39;js/front.js&#39;) }}?v={{ time() }}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ul><h2 id="lecciones-aprendidas" tabindex="-1">Lecciones Aprendidas <a class="header-anchor" href="#lecciones-aprendidas" aria-label="Permalink to &quot;Lecciones Aprendidas&quot;">​</a></h2><ul><li>Usar siempre <code>.includes()</code> y <code>.toLowerCase()</code> al verificar cabeceras HTTP.</li><li>Diseñar parsers de datos para ser &quot;indulgentes&quot; con arrays raíz vs. objetos, especialmente al actuar como proxy de servicios de terceros como n8n.</li><li>Implementar cache-busting para activos críticos de frontend desde el primer día.</li><li>Proporcionar estados de UI de respaldo (como &quot;--&quot;) en lugar de spinners infinitos cuando la resolución de datos falla.</li></ul>',25)])])}const m=a(i,[["render",t]]);export{h as __pageData,m as default};
